---
layout: post
title: Java学习记录
category: java
date: 2015-07-22
---
##2015年6月5日(第一章)
1.面向对象相对于面向过程编程更简单,可以增加代码的复用,面向对象并没有减少实现过程,只是将过程包装成了方法.

2.构造方法的重载在于可以为其输入变量,不同种变量可以用不同的方法重载.

		Circle c1 = new Circle(5);//最后的Circle即为构造方法
	
3.this是一个对象,可以在类里面引用类的成员变量和方法.

4.static关键字,可以允许变量不实例化修改,只存一份,每个对象的static变量都相同,节约空间.
<!-- more -->

##2015年6月8日
1.package的作用是防止java类重名,导致调用出错.约定俗成的规则是域名倒写(如com.baidu.www)

##2015年7月21日
1.不同的项目需要不同的classpath,以避免包的冲突问题.

2.使用jar -cvf *.jar *.*可以打包class文件,便于引用.

3.java只支持单继承(C++允许多继承).

4.继承的子类大于等于父类(子类含有父类方法等).

5.继承所有的变量,但是不能修改只能访问.(protected,public)
	
	-------------------------------------------------
	|   修饰符  | 类内部 | 同一个包  | 子类 | 任何地方 |
	-------------------------------------------------
	|  private  |  Yes  |          |      |         |
	-------------------------------------------------
	|  default  |  Yes  |    Yes   |      |         |
	-------------------------------------------------
	| protected |  Yes  |    Yes   |  Yes |         |
	-------------------------------------------------
	|   public  |  Yes  |    Yes   |  Yes |   Yes   |
	-------------------------------------------------

6.super引用指向当前对象的父类,this引用指向对象自身.

7.子类构造过程中必须调用父类的构造方法.super的调用必须是构造函数的第一个语句.

##2015年7月22日
1.lang中的equals当且仅当指向同一对象,才返回true.但是各个包可能会重写equals.

2.动态绑定(多态)是面向对象的核心,执行期间判断所引用对象的实际类型,根据其实际类型调用其相应的方法.

3.抽象方法用于被重写,方法是抽象的则类也是抽象的,无法被实例化,用于继承.

4.final关键字,不能重写,不能继承.

5.interface属于特殊的抽象类,只包含常量和方法的定义,无实现.接口之间可以相互继承.

##2015年7月23日
1.多维数组相当于其低维数组的数组.

##2015年10月15日
1.容器是装其它东西的器皿(数组),装其它各种对象.
	
	
            Collection(interface)                                         Map(interface)
             |                 |                                                 |
        Set(interface)  List(interface)                                          |  
             |            |        |                                             |
          HashSet     LinkedList  ArrayList                                   HashMap 
   
2.装在Set中无顺序不可重复,List中有顺序可重复,Map中两两存取.(重复是指两个对象互相equals)

3.Collection中装的(add,remove)必须是对象.

4.容器类对象在调用remove,contains等方法时需要比较对象是否相等,会涉及到对象类型的equals方法和hashCode方法,相等的对象具有相等的hashCode.

5.Iterator为容器的迭代器,用于实现对容器内元素的遍历操作.

6.hashSet无顺序,所以经过iterator迭代后输出顺序不定

##2015年10月16日
1.List中元素都对应一个整数型序号记载在其容器的位置,可以根据序号存取容器元素(像数组),List的长度可以根据需要改变.

2.Array读快改慢,Linkded改快读慢,Hash在两者之间.

3.Map接口实现类有HashMap和TreeMap,用来存储Key-Value对,通过Key来标示,不能重复.

4.自动打包:自动将基础类型转换为对象.自动解包:自动将对象转换为基础类型.

5.泛型Generic,创建按类型进行参数化的类,避免类型转换.

6.通过流(Stream)的方式读取数据.

7.system.in接受键盘输入.

##2015年10月17日
1.线程是一个程序内部的顺序控制流.

2.创建线程的方法:1)定义线程类实现Runnable接口.2)定义Thread的子类并重写其run方法.一般用第一种,便与实现多重继承.

3.sleep线程睡眠,join线程合并,yield线程让出.

4.TestSync运行若未加锁可能出现冲突,sleep时间越长可能性越大.

##2015年10月18日
1.wait()和sleep()的区别:
 1)wait属于object类的方法,sleep属于Thread类.
 2)wait需要用notify或者notifyAll来唤醒,sleep时间过后自动唤醒.
 3)wait后不再拥有锁,sleep仍保持锁.
