---
layout: post
title: Java学习记录
category: java
date: 2015-07-22
---
## 2015年6月5日(第一章)
1.面向对象相对于面向过程编程更简单,可以增加代码的复用,面向对象并没有减少实现过程,只是将过程包装成了方法.

2.构造方法的重载在于可以为其输入变量,不同种变量可以用不同的方法重载.

		Circle c1 = new Circle(5);//最后的Circle即为构造方法
	
3.this是一个对象,可以在类里面引用类的成员变量和方法.

4.static关键字,可以允许变量不实例化修改,只存一份,每个对象的static变量都相同,节约空间.
<!-- more -->

## 2015年6月8日
1.package的作用是防止java类重名,导致调用出错.约定俗成的规则是域名倒写(如com.baidu.www)

## 2015年7月21日
1.不同的项目需要不同的classpath,以避免包的冲突问题.

2.使用jar -cvf *.jar *.*可以打包class文件,便于引用.

3.java只支持单继承(C++允许多继承).

4.继承的子类大于等于父类(子类含有父类方法等).

5.继承所有的变量,但是不能修改只能访问.(protected,public)
	
	-------------------------------------------------
	|   修饰符  | 类内部 | 同一个包  | 子类 | 任何地方 |
	-------------------------------------------------
	|  private  |  Yes  |          |      |         |
	-------------------------------------------------
	|  default  |  Yes  |    Yes   |      |         |
	-------------------------------------------------
	| protected |  Yes  |    Yes   |  Yes |         |
	-------------------------------------------------
	|   public  |  Yes  |    Yes   |  Yes |   Yes   |
	-------------------------------------------------

6.super引用指向当前对象的父类,this引用指向对象自身.

7.子类构造过程中必须调用父类的构造方法.super的调用必须是构造函数的第一个语句.

## 2015年7月22日
1.lang中的equals当且仅当指向同一对象,才返回true.但是各个包可能会重写equals.

2.动态绑定(多态)是面向对象的核心,执行期间判断所引用对象的实际类型,根据其实际类型调用其相应的方法.

3.抽象方法用于被重写,方法是抽象的则类也是抽象的,无法被实例化,用于继承.

4.final关键字,不能重写,不能继承.

5.interface属于特殊的抽象类,只包含常量和方法的定义,无实现.接口之间可以相互继承.

## 2015年7月23日
1.多维数组相当于其低维数组的数组.

## 2015年10月15日
1.容器是装其它东西的器皿(数组),装其它各种对象.
	
	
            Collection(interface)                                         Map(interface)
             |                 |                                                 |
        Set(interface)  List(interface)                                          |  
             |            |        |                                             |
          HashSet     LinkedList  ArrayList                                   HashMap 
   
2.装在Set中无顺序不可重复,List中有顺序可重复,Map中两两存取.(重复是指两个对象互相equals)

3.Collection中装的(add,remove)必须是对象.

4.容器类对象在调用remove,contains等方法时需要比较对象是否相等,会涉及到对象类型的equals方法和hashCode方法,相等的对象具有相等的hashCode.

5.Iterator为容器的迭代器,用于实现对容器内元素的遍历操作.

6.hashSet无顺序,所以经过iterator迭代后输出顺序不定

## 2015年10月16日
1.List中元素都对应一个整数型序号记载在其容器的位置,可以根据序号存取容器元素(像数组),List的长度可以根据需要改变.

2.Array读快改慢,Linkded改快读慢,Hash在两者之间.

3.Map接口实现类有HashMap和TreeMap,用来存储Key-Value对,通过Key来标示,不能重复.

4.自动打包:自动将基础类型转换为对象.自动解包:自动将对象转换为基础类型.

5.泛型Generic,创建按类型进行参数化的类,避免类型转换.

6.通过流(Stream)的方式读取数据.

7.system.in接受键盘输入.

## 2015年10月17日
1.线程是一个程序内部的顺序控制流.

2.创建线程的方法:1)定义线程类实现Runnable接口.2)定义Thread的子类并重写其run方法.一般用第一种,便与实现多重继承.

3.sleep线程睡眠,join线程合并,yield线程让出.

4.TestSync运行若未加锁可能出现冲突,sleep时间越长可能性越大.

## 2015年10月18日
1.wait()和sleep()的区别:
 1)wait属于object类的方法,sleep属于Thread类.
 2)wait需要用notify或者notifyAll来唤醒,sleep时间过后自动唤醒.
 3)wait后不再拥有锁,sleep仍保持锁.

2.网络通信协议:计算机网络中实现通信必须有一些约定即通信协议,对码率,传输代码,代码结构.传输控制步骤.出错控制等制定标准.

3.端口号来区分数据传输到目标电脑的应用程序接受位置.

## 2015年11月15日
1.当有指定构造方法,无论它是有参还是无参的构造方法,则系统都不会自动添加无参的构造方法.

2.Java 中被 static 修饰的成员称为静态成员或类成员.它属于整个类所有,而不是某个对象所有,即被类的所有对象所共享.使用 static 可以修饰变量、方法和代码块.

3.静态方法中可以直接调用同类中的静态成员,但不能直接调用非静态成员.(如果希望在静态方法中调用非静态变量,可以通过创建类的对象,然后通过对象来访问非静态变量.)
	
	public class HelloWorld{
		String name = "爱慕课";
		static String hobby = "imooc";
		public static void main(String[] args){
			System.out.println(name);//不能直接调用非静态成员变量
			System.out.println(hobby);//可以直接调用静态成员变量
		}
	}

4.在普通成员方法中,则可以直接访问同类的非静态变量和静态变量.

5.静态初始化块只在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通的成员变量。
	
	public class HelloWorld {
    
	    String name; // 声明变量name
		String sex; // 声明变量sex
		static int age;// 声明静态变量age
	    
	    // 构造方法
		public HelloWorld() { 
			System.out.println("通过构造方法初始化name");
			name = "tom";
		}
	    
	    // 初始化块
		{ 
			System.out.println("通过初始化块初始化sex");
			sex = "男";
		}
	    
	    // 静态初始化块
	    static{ 
			System.out.println("通过静态初始化块初始化age");
			age = 20;
		}
	    
		public void show() {
			System.out.println("姓名：" + name + "，性别：" + sex + "，年龄：" + age);
		}
	    
		public static void main(String[] args) {
		
		// 创建对象
			HelloWorld hello = new HelloWorld();
			// 调用对象的show方法
		hello.show();
		HelloWorld hello2 = new HelloWorld();
		}
	}

6.内部类的主要作用如下：
 1)内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类
 2)内部类的方法可以直接访问外部类的所有数据，包括私有的数据
 3)内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便

7.外部类不能直接使用内部类的成员和方法,需要使用外部类对象来创建内部类对象，然后通过内部类的对象来访问其成员变量和方法.
	
	内部类 内部对象名 = 外部类对象名.new 内部类构造方法

8.如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this 关键字.

9.静态内部类的特点：
 1）静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问 
 2）如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员
 3）创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名= new 内部类();
